---
title: Java char 类型转换问题（一）
date: 2018-07-18 15:30:00
tags: [Java, Java char, Java强制类型转换]
---

### 1. 疑惑
之前在看移位时注意到 char 的几个问题，我们先看一个例子
```java
class ShiftTest{
        public static void main(String[] args) {
            int i = -1;
            char c = (char) i;
            System.out.println(String.format("%-15s:%s", "c's binary str", Integer.toBinaryString(c)));
            System.out.println(String.format("%-15s:%s", "c's char", c));
            System.out.println(String.format("%-15s:%s", "(int)c1", (int) c));
    
            char c1 = (char) -1;
            System.out.println(String.format("%-15s:%s", "c1 binary str", Integer.toBinaryString(c1)));
            c1 >>= 15;
            System.out.println(String.format("%-15s:%s", "c1 >>>= 15", Integer.toBinaryString(c1)));
    
            char c2 = (char) -1;
            c2 >>= 17;
            System.out.println(String.format("%-15s:%s", "c2 >>>= 17", Integer.toBinaryString(c2)));
    
            char c3 = (char) -1;
            c3 >>= 31;
            System.out.println(String.format("%-15s:%s", "c3 >>>= 31", Integer.toBinaryString(c3)));
    
            char c4 = (char) -1;
            c4 >>= 33;
            System.out.println(String.format("%-15s:%s", "c4 >>>= 33", Integer.toBinaryString(c4)));
        }
}
```
这段代码的输出结果如下：
```
c's binary str :1111111111111111
c's char       :￿
(int)c1        :65535
c1 binary str  :1111111111111111
c1 >>>= 15     :1
c2 >>>= 17     :0
c3 >>>= 31     :0
c4 >>>= 33     :111111111111111
```
这里可以提出我的疑惑了：
- a. int的 -1 强转为 char 后，再强转回 int 的输出为什么是65535
- b. (char)-1右移15、17、31、33位对应的值

先强调一个知识点——各个数据类型位数长度是不一样的，Java使用的是二进制的补码运算。
然后我们针对这两个问题详细分析一下。

### 2. 问题原因
#### 2.1. 问题a：
```
int -1的原码：1000 0000 0000 0000 0000 0000 0000 0001
int -1的反码：1111 1111 1111 1111 1111 1111 1111 1110
int -1的补码：1111 1111 1111 1111 1111 1111 1111 1111
```
第一步强转为char时，高位截断后：
```
补码：1111 1111 1111 1111
```
第二步强转会int时：

这里需要补充一个规则
```
有一条很简单的规则能够描述从较窄的整型转换成较宽的整型时的符号扩展行为：
如果最初的数值类型是有符号的，那么就执行符号扩展；
如果它是char，那么不管它将要被转换成什么类型，都执行零扩展
```
因此，再强转回int时
```
补码：0000 0000 0000 0000 1111 1111 1111 1111
```
最高位为 0，所以当做正数处理，原反补都一样，转成 10 进制即为 65535

#### 2.2. 问题b：
char在进行移位操作时分几个步骤：
```
第一步，转成int
第二步，按照int进行移位
第三步，转回char
```
#### 2.2.1. (char)-1 >>> 15：
```
前面说过 (char)-1 的补码:
1111 1111 1111 1111
转为int后:
0000 0000 0000 0000 1111 1111 1111 1111
执行 >>>15：
0000 0000 0000 0000 0000 0000 0000 0001
转char：
0000 0000 0000 0001
```
所以结果为 1

#### 2.2.2. (char)-1 >>> 17：
```
前面说过 (char)-1 的补码:
1111 1111 1111 1111
转为int后:
0000 0000 0000 0000 1111 1111 1111 1111
执行 >>>17：
0000 0000 0000 0000 0000 0000 0000 0000
转char：
0000 0000 0000 0000
```
所以结果为 0

#### 2.2.3. (char)-1 >>> 31：
```
前面说过 (char)-1 的补码:
1111 1111 1111 1111
转为int后:
0000 0000 0000 0000 1111 1111 1111 1111
执行 >>>31：
0000 0000 0000 0000 0000 0000 0000 0000
转char：
0000 0000 0000 0000
```
所以结果为 0


#### 2.2.4. (char)-1 >>> 33：
```
前面说过 (char)-1 的补码:
1111 1111 1111 1111
转为int后:
0000 0000 0000 0000 1111 1111 1111 1111
执行 >>>33：
（这里，需要遵循 int 的移位规则了， 33 超出了 int 类型的长度，33 按 int 位长 32 取余得 1， 相当于 >>> 1）  
0000 0000 0000 0000 0111 1111 1111 1111
转char：
0111 1111 1111 1111
```
所以输出结果的二进制字符串是 15 个 1

