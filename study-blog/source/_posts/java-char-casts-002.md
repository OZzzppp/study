---
title: Java char 类型转换问题（二）
date: 2018-07-20 16:30:00
tags: [Java, Java char, Java强制类型转换]
---

基于上一篇blog中提到的一个规则，在本文中做一个详细解释，规则内容：
```
从较窄的整型转换成较宽的整型时的符号扩展：
如果最初的数值类型是有符号的，那么就执行符号扩展；
如果它是char，那么不管它将要被转换成什么类型，都执行零扩展
```
例子：
```java
public class ShiftTest{
    public static void main (String[] args){
        System.out.println((int)(char)(byte) -1);
    }
}
```
输出结果：
```j
65535
```
### 分析
#### 第一步：(byte) -1
```
int -1的原码：1000 0000 0000 0000 0000 0000 0000 0001
int -1的反码：1111 1111 1111 1111 1111 1111 1111 1110
int -1的补码：1111 1111 1111 1111 1111 1111 1111 1111
```
转换为byte时，高位截断，则(byte) -1的补码为：
```
补码：1111 1111
```
#### 第二步：(char)(byte) -1
从 byte 到 char 的转型比较麻烦一点，因为 byte 是一个有符号类型，而 char 是一个无符号类型。
在将一个整数类型转换成另一个宽度更宽的整数类型时，通常是可以保持其数值的，
但是却不可能将一个负的 byte 数值表示成一个 char 。
因此，从 byte 到 char 的转换被认为不是一个拓宽原始类型的转换，
而是一个拓宽并窄化原始类型的转换（[widening and narrowing primitive conversion](https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html)）：byte被转换成了int，而这个int再被转换成了char。

于是回到文章开头提到的规则，这个规则原话内容应该是出自《Java解惑》，按照规则，变换之后：
 ```
 补码：1111 1111 1111 1111
 ```
#### 第三步：(int)(char)(byte) -1
按照规则，char 不管它将要被转换成什么类型，都执行零扩展，则：
 ```
 补码：0000 0000 0000 0000 1111 1111 1111 1111
 ```
 所以最终结果为：65535